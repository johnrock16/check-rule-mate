var R={propertiesMustMatch:!0,abortEarly:!1,cache:!0};function S(n,{validationHelpers:g={},rules:k,schema:i,errorMessages:m={},hooks:p={},options:y=R}){y={...R,...y},n=n;let l={},u={},f={all:async e=>Promise.all([...e].map(async r=>await v(r,n))),first:async e=>{let r=[];for(let a of e){let t=await v(a,n);if(r.push(t),!t)return r}return r}};function h(e,r){if(!e||typeof r!="string")return;let a=r.split("."),t=e;for(let V of a){if(t[V]===void 0)return;t=t[V]}return t}async function v(e,r=null){if(o("onValidateFieldStart",{field:e.key,value:e.value,schemaField:i[e.key]||null}),i[e.key]){let{rule:a,required:t}=i[e.key];if((i[e.key]?.cache!==void 0?i[e.key].cache:y.cache)&&r[e.key]===u[e.key]?.value)return u[e.key].isValid;if((a&&t||!t&&e.value!="")&&a){let s=a.split("--")[0],O=a.split("--").length>1?a.split("--")[1]:"",q=I(e.value,k[s],O,g,r),{isValid:E,errorMessage:w,errorType:P}=await q.validate();if(E)o("onValidateFieldSuccess",{field:e.key,value:e.value,schemaField:i[e.key]});else{let F={name:e.key,field:e.key,code:w,type:P,message:h(m,w)||""};l[e.key]=F,o("onValidateFieldError",{field:e.key,value:e.value,schemaField:i[e.key],error:F})}return u[e.key]={isValid:E,value:r[e.key]},E}}else if(y.propertiesMustMatch){let a={name:e.key,field:e.key,message:"Invalid property",internal:!0};return l[e.key]=a,o("onValidateFieldError",{field:e.key,value:e.value,error:a}),!1}return o("onValidateFieldSuccess",{field:e.key,value:e.value}),!0}async function c(e){return await v({key:e,value:n[e]},n)?{ok:!0}:{error:!0,errors:l[e]}}async function d(){o("onValidateStart",{data:n}),l={};let e=Object.keys(n).map(r=>({key:r,value:n[r]}));if(e&&e.length>0){if(!Object.keys(i).every(s=>n.hasOwnProperty(s)))return o("onValidateEnd",{data:n,errors:[{name:"internal: schema - missing properties",message:"Missing properties",internal:!0}]}),{error:!0,errorMessage:"Missing properties"};if((y?.abortEarly?await f.first(e):await f.all(e)).some(s=>!s))return o("onValidateEnd",{data:n,errors:l}),{error:!0,errors:l};let a=Object.keys(i).map(s=>({key:s,required:i[s].required})),t=e.map(s=>s.key);if(!a.filter(s=>s.required).map(s=>s.key).every(s=>t.includes(s))){let s={error:!0};return o("onValidateEnd",{data:n,errors:[{name:"internal: fields - required",message:"",internal:!0}]}),s}}else if(!e||e.length===0){let r={error:!0,errorMessage:"Missing fields for schema"};return o("onValidateEnd",{data:n,errors:[{name:"internal: schema - missing fields",message:r.errorMessage,internal:!0}]}),r}return o("onValidateEnd",{data:n}),{ok:!0}}function o(e,r){p?.[e]&&typeof p[e]=="function"&&p[e]({...r})}function M(e){n=e}return{validate:d,validateField:c,setData:M}}function I(n,g,k=null,i=null,m=null){async function p(l){let u,f;return{isValid:!(await Promise.all(l.validate.map(async c=>{let d=!0;if(l.params&&l.params[c]&&l.params[c].length>0){let o=l.params[c].map(e=>typeof e=="string"&&e[0]==="$"?e.substring(1,e.length):e);d=await this[c](...o)}else d=await this[c]();return!d&&!u&&l?.error[c]&&(u=l.error[c],f=c),d}))).some(c=>!c),errorMessage:u,errorType:f}}async function y(){if(i&&typeof i=="function"){let u=i(n,g,k,m);Object.keys(u).forEach(f=>{this[f]=u[f]})}return k?await p.call(this,g.modifier[k]):await p.call(this,g)}return{validate:y}}export{S as createValidator};
