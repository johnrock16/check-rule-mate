# Core Concepts

**check-rule-mate** is built around a small set of **core concepts** that work together to form a **flexible** and **extensible validation system**.

Understanding these **concepts** is **essential** to using the library effectively.

This document explains **what each concept is**, **why it exists**, and **how they interact** without going into implementation details.

## Mental Model
**check-rule-mate is NOT a traditional schema validator**.

Instead of embedding validation logic directly into schemas, **check-rule-mate separates validation into independent layers**, allowing rules to be reused, extended, and executed in different contexts.

- Rules define validation logic (Rules define how to validate.)
- Schemas only decide when and where those rules apply (Schemas define what to validate.)

This separation enables:

- Cross-field validation
- Contextual rules
- Async validation
- Reusability across forms and services
- Clear execution flow

## Core Building Blocks

check-rule-mate is built on four main concepts:

- **Rules**: How data is validated
- **Schemas**: What should be validated
- **Validation Helpers**: How rules are executed
- **Error Messages**: How validation errors are communicated

Each layer has a **single responsibility**.

## 1. Rules - How to Validate
Rules describe **what validation steps should happen**, but they do **not execute logic** themselves.

They:

- Are defined in JSON
- Do not contain executable code
- Are reusable across multiple schemas
- Can be extended using modifiers
- Do not know about UI, forms, or frameworks

### Example Rule:
```json
{
  "email": {
    "regex": "/^[a-z0-9.]+@[a-z0-9]+\\.[a-z]+(\\.[a-z]+)?$/i",
    "validate": ["regex"],
    "error": {
      "regex": "email.regex"
    },
    "modifier": {
      "confirm": {
        "validate": ["regex", "equals"],
        "params": {
          "equals": ["$email"]
        },
        "error": {
          "regex": "email.regex",
          "equals": "email.equals"
        }
      }
    }
  }
}
```

### Rule Characteristics
- Rules **do not know about schemas**
- Rules **do not contain JavaScript**
- Rules **do not produce messages**
- Rules **only describe validation behavior**

### Rule Responsibilities
A rule may define:
- **validate**: ordered list of validation steps
- **regex**: optional regex pattern
- **params**: parameters passed to helpers
- **error**: mapping between validation steps and error keys
- **modifier**: contextual rule extensions

Rules never:
- Access form data directly
- Contain error messages
- Know where they are used

### Modifiers
Modifiers extend a rule **without duplicating it**.

Example usage in a schema:
```json
"email--confirm"
```

Internally:

- Base rule: `email`
- Modifier: `confirm`

Modifiers can override:

- `validate`
- `params`
- `regex`
- `error`

This makes rules **highly reusable and expressive**.

### Dynamic Parameters ($field)
Rules can reference **other fields dynamically**:

```json
"params": {
  "equals": ["$email"]
}
```
At runtime:
- `$email` resolves to `form.email`
- Enables **true coss-field validation**

## 2. Schema - What to Validate
Schemas **map data fields to rules.**

They:

- Decide which rule applies to which field
- Declare required/optional fields
- Control caching behavior
- Reference rule modifiers

Schemas do **not** define validation logic.

### Example Schema:
```json
{
  "email": {
    "rule": "email",
    "required": true
  },
  "emailConfirm": {
    "rule": "email--confirm",
    "required": true
  },
  "phone": {
    "rule": "phone",
    "required": false
  }
}
```

Schemas:

- Select which rule applies to each field
- Define required/optional fields
- Control caching behavior

Schemas do **not**:

- Define validation logic
- Define regex
- Define error messages

## 3. Validation Helpers - Execution Layer
Validation helpers are where **rules are executed**.

They are JavaScript functions that implement the behavior described by rules.

### Example helper:
```javascript
const myValidator = function (value, rule, modifier = null, data = null) {
  function regex() {
    const regexTemplate = rule.modifier?.[modifier]?.regex || rule.regex;
    const regex = new RegExp(regexTemplate);
    return regex.test(value);
  }

  function hasText() {
    return value.trim().length > 0;
  }

  function equals(key) {
    return value === data[key];
  }

  return { regex, hasText, equals };
};
```

### Helper Signature
```typescript
(value, rule, modifier?, data?) => Record<string, Function>
```

### Key Properties

- Helpers return an **object of validation functions**
- Each function corresponds to a key in `validate`
- Functions can be **sync or async**
- Helpers are **stateless**
- Helpers can access the **entire dataset**

## 4. Error Messages — Communication Layer
Error messages are resolved using **keys**, not hardcoded strings.

Example:
```json
{
  "email": {
    "regex": "Please enter a valid email",
    "equals": "Emails do not match"
  }
}
```
Rules reference errors by key:
```json
"email.regex"
```

This design enables:

- Localization (i18n)
- Custom messaging per project
- UI independence

## Lifecycle Hooks
Hooks allow observing and reacting to the validation process without coupling logic to rules or schemas.

Available hooks:
```typescript

hooks?: {
  onValidateStart?: (payload) => void;
  onValidateFieldStart?: (payload) => void;
  onValidateFieldError?: (payload) => void;
  onValidateFieldSuccess?: (payload) => void;
  onValidateEnd?: (payload) => void;
}
```
Hooks are ideal for:
- Logging
- Debugging
- Analytics
- UI updates
- Side effects

## Execution Flow Summary
A simplified execution flow:

1. Validation starts → `onValidateStart`
2. Each field is processed
    - `onValidateFieldStart`
    - Rule + modifier resolved
    - Helpers executed in order
    - Errors collected or aborted
    - `onValidateFieldError` or `onValidateFieldSuccess`

3. Validation ends → `onValidateEnd`
4. Result returned

## Why This Architecture Matters

This separation allows:
- Reusing rules across multiple schemas
- Sharing validation logic between frontend and backend
- Supporting complex business rules
- Avoiding schema bloat
- Maintaining clear ownership of logic

## When This Model Shines
Use check-rule-mate when:

- Validation rules are complex or shared
- Business logic must remain declarative
- Cross-field validation is required
- Async validation is needed
- Validation must be observable and extensible

## What check-rule-mate is not
- Not a simple schema validator
- Not opinionated about UI
- Not tied to any framework
- Not designed for trivial forms

## What check-rule-mate is
- A rule-driven validation engine
- A reusable business rules layer
- A tool for complex validation scenarios
- A validation system with observability

## Summary

| Concept | Responsibility               |
| ------- | ---------------------------- |
| Rules   | Describe validation behavior |
| Schema  | Orchestrate validation       |
| Helpers | Execute validation           |
| Errors  | Communicate results          |

Together, these concepts form a **powerful, flexible, and explicit validation system**.