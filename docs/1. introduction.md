# Introduction

**check-rule-mate** is a rule-based validation engine for JavaScript designed to handle **complex validation scenarios** with clarity, flexibility, and control.

Unlike traditional schema-driven validators, check-rule-mate separates validation concerns into **rules**, **schemas**, **execution helpers**, and **error messages**, allowing you to build reusable, composable, and context-aware validation logic that scales with your application.

This project was created to solve problems that often arise when validation logic becomes:
- Hard to reuse
- Tightly coupled to forms or schemas
- Difficult to extend with cross-field or async rules
- Scattered across codebases

check-rule-mate treats validation as **a system**, not just a utility.

---

## What problem does it solve?

Most validation libraries work well for simple forms, but start to break down when you need:

- Cross-field validation (e.g. email confirmation)
- Contextual rules (same rule, different behavior)
- Async validation (API calls, database checks)
- Reusable validation logic across multiple forms
- Clear separation between validation logic and error messages
- Validation that works the same on frontend and backend

check-rule-mate addresses these problems by introducing a **rule-driven architecture**, where validation logic is decoupled from data structures and execution flow.

---

## Core Philosophy

check-rule-mate is built around a few core ideas:

### 1. Rules should be reusable
Validation logic should not be rewritten for each form.
Rules are defined once and reused everywhere.

### 2. Schemas describe *what* to validate, not *how*
Schemas map data fields to rules, without embedding logic.

### 3. Execution is explicit and controllable
You decide:
- When validation stops
- Whether to collect all errors or abort early
- How strict schema matching should be
- How async rules behave

### 4. Validation should be observable
Through **lifecycle hooks**, you can track:
- When validation starts
- When a field is validated
- When a field succeeds or fails
- When validation ends

This makes debugging, logging, analytics, and UI integration straightforward.

---

## How check-rule-mate is different

check-rule-mate is **not** a replacement for simple validators.

It is designed for cases where:
- Business rules matter
- Validation logic evolves over time
- Multiple forms share the same rules
- Validation needs to be documented, tested, and audited

If your validation needs are simple, other libraries may be a better fit.
If your validation logic is complex, check-rule-mate gives you structure instead of workarounds.

---

## High-level architecture

At a high level, check-rule-mate is composed of:

- **Schemas** → define which fields are validated and which rules apply
- **Rules** → define reusable validation logic
- **Validation helpers** → implement how rules execute
- **Error messages** → define how validation errors are communicated
- **Validator engine** → orchestrates execution
- **Hooks** → allow observing and extending the lifecycle
- **CLI tools** → enable verification and documentation

Each part is independent and replaceable.

---

## Who should use check-rule-mate?

check-rule-mate is a good fit if you:

- Build complex forms or APIs
- Share validation logic between frontend and backend
- Need validation rules that evolve with business requirements
- Want predictable, testable, and debuggable validation flows
- Prefer explicit architecture over “magic” abstractions

---

## What’s next?

The next sections will walk you through the core concepts in detail:

- How schemas work
- How rules and modifiers are defined
- How validation helpers execute logic
- How hooks integrate into the lifecycle
- How the CLI and auto-documentation work

By the end, you should be able to design validation systems, not just validate fields.
